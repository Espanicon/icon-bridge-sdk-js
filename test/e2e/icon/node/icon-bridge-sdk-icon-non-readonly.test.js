// E2E Tests.
require("dotenv").config();
const IconBridgeSDK = require("../../../../dist/icon-bridge-sdk-node");
const assert = require("assert");

// Icon Bridge SDK
const sdk = new IconBridgeSDK({
  useMainnet: false
});

// test wallets
const wallets = {
  icon: {
    pubK: process.env.WALLET_ICON_ADDRESS,
    privK: process.env.WALLET_ICON_PK
  },
  bsc: {
    pubK: process.env.WALLET_BSC_ADDRESS,
    privK: process.env.WALLET_BSC_PK
  }
};

const contracts = sdk.sdkUtils.contracts.icon.testnet;
const labels = sdk.sdkUtils.labels;
const wrappedTokenContract = contracts[labels.bnb].address;
const nativeTokenContract = contracts[labels.sicx].address;
// const btsContract = contracts[labels.bts].address;

// Keys that should appear in any response from a readonly call
// originating from the ICON chain.
const genericResultKeys = ["id", "jsonrpc", "result"];

// ********************************************//
// Test 1: calls 'transferNativeCoin' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 1: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transferNativeCoin(targetAddress, targetChain, from, pk, amount)'", () => {
  it("Returns tx hash of the transfer of native coin from ICON chain to BSC chain.", async () => {
    const query = await sdk.icon.methods.transferNativeCoin(
      wallets.bsc.pubK,
      "bsc",
      wallets.icon.pubK,
      wallets.icon.privK,
      "50"
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(5000);
});

// ********************************************//
// Test 2: calls 'transferNativeToken' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 2: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transferNativeToken(tokenName, amount, targetAddress, targetChain, TokenContract, from, pk, amount)'", () => {
  it("Returns tx hash of the transfer of a native token from the ICON chain to the BSC chain.", async () => {
    const query = await sdk.icon.methods.transferNativeToken(
      "btp-0x2.icon-sICX",
      "20",
      wallets.bsc.pubK,
      "bsc",
      nativeTokenContract,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 3: calls 'transferWrappedToken' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 3: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transferWrappedToken(tokenName, amount, targetAddress, targetChain, TokenContract, from, pk)'", () => {
  it("Returns tx hash of the transfer of a wrapped token from the ICON chain to the BSC chain.", async () => {
    const query = await sdk.icon.methods.transferWrappedToken(
      "btp-0x61.bsc-BNB",
      "0.1",
      wallets.bsc.pubK,
      "bsc",
      wrappedTokenContract,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 4: calls 'reclaim' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 4: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'reclaim(_coinName, _value, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'reclaim' method.", async () => {
    const query = await sdk.icon.methods.reclaim(
      "btp-0x61.bsc-BNB",
      "0.1",
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 5: calls 'addOwner' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 5: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'addOwner(_addr, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'addOwner' method.", async () => {
    const query = await sdk.icon.methods.addOwner(
      wallets.icon.pubK,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 6: calls 'removeOwner' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 6: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'removeOwner(_addr, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'removeOwner' method.", async () => {
    const query = await sdk.icon.methods.removeOwner(
      wallets.icon.pubK,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 7: calls 'register' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 7: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'register(_name, _symbol, _decimals, _feeNumerator, _fixedFee, _addr, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'register' method.", async () => {
    const query = await sdk.icon.methods.register(
      "btp-0x61.bsc-WBNB",
      "BNB",
      "0x12",
      "0x0",
      "0x2aa1efb94e000",
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 8: calls 'setFeeRatio' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 8: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'setFeeRatio(_name, _feeNumerator, _fixedFee, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'setFeeRatio' method.", async () => {
    const query = await sdk.icon.methods.setFeeRatio(
      "btp-0x61.bsc-WBNB",
      "0x0",
      "0x2aa1efb94e000",
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 9: calls 'removeBlacklistAddress' method originating on the Icon
// chain. It should returns and object with a predefined set of keys.
describe("Test 9: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'removeBlacklistAddress(_net, _addresses, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'removeBlacklistAddress' method.", async () => {
    const query = await sdk.icon.methods.removeBlacklistAddress(
      "0x61.bsc",
      [wallets.icon.pubK],
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 10: calls 'setTokenLimit' method originating on the Icon
// chain. It should returns and object with a predefined set of keys.
describe("Test 10: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'setTokenLimit(_coinNames, _tokenLimits, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'setTokenLimit' method.", async () => {
    const query = await sdk.icon.methods.setTokenLimit(
      ["btp-0x61.bsc-WBNB"],
      ["0x0"],
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 11: calls 'addBlacklistAddress' method originating on the Icon
// chain. It should returns and object with a predefined set of keys.
describe("Test 11: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'addBlacklistAddress(_net, _addresses, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'addBlacklistAddress' method.", async () => {
    const query = await sdk.icon.methods.addBlacklistAddress(
      "0x61.bsc",
      [wallets.bsc.pubK],
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 12: calls 'addRestriction' method originating on the Icon
// chain. It should returns and object with a predefined set of keys.
describe("Test 12: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'addRestriction(from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'addRestriction' method.", async () => {
    const query = await sdk.icon.methods.addRestriction(
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 13: calls 'disableRestrictions' method originating on the Icon
// chain. It should returns and object with a predefined set of keys.
describe("Test 13: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'disableRestrictions(from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'disableRestrictions' method.", async () => {
    const query = await sdk.icon.methods.disableRestrictions(
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 14: calls 'transferToBTSContract' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 14: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transferToBTSContract(_value, tokenContract, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'transferToBTSContract' method.", async () => {
    const query = await sdk.icon.methods.transferToBTSContract(
      "40",
      nativeTokenContract,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 15: calls 'transfer' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 15: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transfer(_coinName, _value, _to, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'transfer' method.", async () => {
    const query = await sdk.icon.methods.transfer(
      "btp-0x2.icon-sICX",
      "20",
      "bsc",
      wallets.bsc.pubK,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 16: calls 'approveBTSContract' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 16: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'approveBTSContract(amount, tokenContract, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'approveBTSContract' method.", async () => {
    const query = await sdk.icon.methods.approveBTSContract(
      "0.1",
      wrappedTokenContract,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});

// ********************************************//
// Test 17: calls 'transferBatch' method originating on the Icon chain.
// It should returns and object with a predefined set of keys.
describe("Test 17: E2E testing Icon Bridge SDK. Chain: 'icon', Method 'transferBatch(_coinNames, _values, _to, from, pk)'", () => {
  it("Returns tx hash of the transfer generated by calling the 'transferBatch' method.", async () => {
    const query = await sdk.icon.methods.transferBatch(
      ["btp-0x2.icon-sICX", "btp-0x61.bsc-BNB"],
      ["20", "0.1"],
      "bsc",
      wallets.bsc.pubK,
      wallets.icon.pubK,
      wallets.icon.privK
    );
    // check if the result query has the valid keys
    const result = Object.keys(query).map(key => {
      if (genericResultKeys.includes(key)) {
        return true;
      }
      return false;
    });

    console.log(`\n  > Result: ${JSON.stringify(query)}\n`);
    assert.ok(!result.includes(false));
  }).timeout(10000);
});
